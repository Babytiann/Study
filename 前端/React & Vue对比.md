# 1.React 对比Vue的DOM生成与更新

## 1.1DOM生成

二者都采用**虚拟 DOM**

- **Vue**:
  - Vue 使用的是一个轻量级的虚拟 DOM。每当数据变化时，Vue 会创建一个虚拟 DOM 树并将其与旧的虚拟 DOM 树进行比较（称为 "diffing"）。然后，Vue 会根据差异更新实际的 DOM。
  - Vue 的响应式系统基于数据的 getter 和 setter 机制，当数据变化时，视图会自动更新。
- **React**:
  - React 也使用虚拟 DOM 进行渲染优化。React 会将组件的 JSX 渲染为虚拟 DOM 树，并在状态或属性变化时通过 diff 算法进行比较，最终更新真实的 DOM。
  - React 的响应式系统基于 `setState`（或 Hook 中的 `useState`），每次状态改变时都会重新渲染组件。

## 1.2DOM更新

### Vue

​		Vue 使用 **响应式系统** 和 **虚拟 DOM** 来处理 DOM 更新。其主要流程如下：

#### 1. **数据变化触发更新**

- Vue 通过 **getter/setter** 机制对组件的数据进行响应式处理。当数据（如组件的 `data`）发生变化时，Vue 会自动触发更新。
- 在数据变化时，Vue 会 **通知依赖该数据的组件或 DOM 节点**，然后准备重新渲染相关部分。

#### 2. **依赖追踪**

- Vue 在组件创建时会建立依赖关系。每当某个数据发生变化时，Vue 会 **标记受影响的组件和 DOM 节点**，这些组件和节点被记录为依赖（称为 "依赖追踪"）。
- Vue 使用一个观察者模式来跟踪哪些计算属性和方法依赖于哪些数据，从而确保只更新那些受影响的部分。

#### 3. **虚拟 DOM 和 Diff 算法**

- 数据变化触发组件重新渲染后，Vue 会生成一个新的虚拟 DOM 树，然后与旧的虚拟 DOM 树进行对比（Diff 算法）。
- Vue 通过使用 **递归比对** 和 **层级对比** 的方式 **最小化的 DOM 更新** 来提高性能，仅更新发生变化的部分（例如，只更新被修改的子组件或 DOM 节点，而不是整个 DOM 树）。

#### 4. **异步更新队列与微任务**

- Vue 的 DOM 更新并不会立即执行，而是会被 **异步队列** 收集。在数据变化之后，Vue 会等待当前的任务（事件处理、计算属性等）完成后，再通过 **微任务**（Microtask）机制批量更新 DOM。
- Vue 使用 **`nextTick`** 来处理 DOM 更新。在下一次事件循环的 "微任务" 阶段，Vue 会执行队列中的 DOM 更新操作。

#### 任务队列与微任务的具体流程：

- 数据变化时，Vue 会在微任务队列中安排 DOM 更新操作。
- 当前任务（如用户事件）执行完毕后，Vue 会在 **微任务队列** 中执行 DOM 更新，确保数据变化后，DOM 更新尽可能地高效。
- **微任务** 会在 DOM 更新前先执行，这样可以保证 DOM 在下一次渲染前完成必要的更新。

#### 5. **实际的 DOM 更新**

- 在微任务队列执行完毕之后，Vue 会通过 **最小化更新策略** 将虚拟 DOM 与实际 DOM 进行比对，只更新那些发生变化的 DOM 节点。

### React

#### 1. **状态变化触发更新**

- 当 React 组件的状态（`state`）或属性（`props`）发生变化时，会触发组件的 **重新渲染**。
- 在函数组件中，状态变化通过 `useState` 来触发更新，在类组件中则通过 `setState` 来更新。

#### 2. **重新渲染和虚拟 DOM**

- 状态变化后，React 会调用组件的渲染函数，生成新的虚拟 DOM 树。
- React 会将新生成的虚拟 DOM 与上一次的虚拟 DOM 进行比较（即 **diff 算法**）。

#### 3. **Reconciliation（协调）算法**

- React 使用 **reconciliation** 算法（协调算法，这是一个算法框架，包含diff算法）来比较新旧虚拟 DOM 树之间的差异。这个算法的目标是高效地对比两棵树，找到它们之间的差异，然后通过 **最小化的 DOM 更新** 仅更新那些有差异的部分。
- React 在列表渲染时使用 **`key` 属性** 来帮助算法识别哪些元素是相同的，从而避免不必要的重渲染。

#### 4. **事件循环和任务队列**

- React 的 **事件处理** 会通过 **批量更新机制** 来优化性能。多个状态更新操作会被合并到一个更新任务中，而不是每次都触发单独的 DOM 更新。
- React 使用 **任务队列** 来处理异步更新，所有的更新操作会被放入一个队列中，按顺序执行。

#### 5. **微任务和宏任务**

- React 通过 **微任务队列** 来执行状态更新后的 DOM 更新。React 的 DOM 更新操作会被推送到微任务队列中，确保更新不会被过早或过晚地执行。
- React 的更新通过 **`ReactDOM.flushSync()`** 来保证同步更新。当需要紧急同步更新 DOM 时，React 会通过这个方法在当前任务完成之前立即更新视图。

#### 6. **渲染更新和批量更新**

- React 会将多个状态更新合并成一个批量更新操作，这样可以减少不必要的 DOM 更新操作。
- **React.memo** 和 **shouldComponentUpdate** 可以帮助组件避免不必要的重新渲染，提升性能。



React和Vue都使用微任务来更新DOM，只是React会结合reconcilication 算法以及key属性来更新以提高效率

diff算法是reconcilication算法的一部分，也是核心之一

## 2.关于更新DOM的任务队列的某些知识

**微任务，宏任务**都是异步的任务，优先级比同步的低，比如有一下代码

```
console.log("开始");

setTimeout(() => {
  console.log("宏任务：setTimeout");
}, 0);

Promise.resolve().then(() => {
  console.log("微任务：Promise");
});

console.log("结束");
```

这个运行完会输出

```
开始
结束
微任务：Promise
宏任务：setTimeout
```

